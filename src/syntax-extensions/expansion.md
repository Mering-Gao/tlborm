# 宏展开

展开相对简单。在生成 AST *之后* ，对程序进行语义理解之前的某个时间点，编译器将会对所有宏进行展开。

这一过程包括，遍历 AST，定位所有宏调用，并将它们用其展开进行替换。

在非宏的语法扩展情境中，此过程具体如何发生根据具体情境各有不同。
但所有语法扩展在展开完成之后所经历的历程都与宏所经历的相同。

每当编译器遇见一个语法扩展，都会根据上下文解析成语法元素集。
该语法扩展的展开结果应能被顺利解析为集合中的某个元素。

举例来说，如果在模组作用域内调用了宏，
那么编译器就会尝试将该宏的展开结果解析为一个表示某项条目 (item) 的 AST 节点。
如果在需要表达式的位置调用了宏，那么编译器就会尝试将该宏的展开结果解析为一个表示表达式的AST节点。

事实上，语义扩展能够被转换成以下任意一种：

* 一个表达式
* 一个模式
* 一个类型
* 零或多个条目（包括的 `impl` 块）
* 零或多个语句

换句话讲，宏调用所在的位置，决定了该宏展开之后的结果被解读的方式。

编译器将把 AST 中表示宏调用的节点用其宏展开的输出节点完全替换。
这一替换是结构性 (structural) 的，而非织构性 (textural) 的。

比如思考以下代码：

```rust,ignore
let eight = 2 * four!();
```

我们可将这部分 AST 表示为：

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
```

根据上下文，`four!()` 必须展开成一个表达式 (初始化语句只可能是表达式)。
因此，无论实际展开结果如何，它都将被解读成一个完整的表达式。

此处我们假设，`four!` 的定义保证它被展开为表达式 `1 + 3`。
故而，展开这一宏调用将使整个 AST 变为：

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
```

这又能被重写成：

```rust,ignore
let eight = 2 * (1 + 3);
```

注意到虽然表达式本身不包含括号，我们仍加上了它们。
这是因为，编译器总是将宏展开结果作为完整的AST节点对待，而 *不是* 仅仅作为一列标记。
换句话说，即便不显式地把复杂的表达式用括号包起来，
编译器也不可能“错意”宏替换的结果，或者改变求值顺序。

理解这一点——宏展开被当作AST节点看待——非常重要，它造成两大影响：

* 宏不仅调用位置有限制，其展开结果也 *只能* 跟语法分析器在该位置所预期的 AST 节点种类一致。
* 因此，宏 *必定无法* 展开成不完整或不合语法的结构。

有关展开还有一条值得注意：
如果某次语法扩展的展开结果包含了 *另一次* 语法扩展调用，那会怎么样？
例如，上述 `four!` 如果被展开成了 `1 + three!()`，会发生什么?

```rust,ignore
let x = four!();
```

展开成：

```rust,ignore
let x = 1 + three!();
```

编译器将会检查扩展结果中是否包含更多的宏调用；
如果有，它们将被进一步展开。
因此，上述 AST 节点将被再次展开成：

```rust,ignore
let x = 1 + 3;
```

这个例子告诉我们，宏展开发生在“传递”过程中；要完全展开所有调用，就需要同样多的传递。

嗯，也不全是如此。
事实上，编译器为此设置了一个上限。它被称作宏递归上限，默认值为 128。
如果第 128 次展开结果仍然包含宏调用，编译器将会终止并返回一个递归上限溢出的错误信息。

此上限可通过 [`#![recursion_limit="…"]`][recursion_limit] 被改写，
但这种改写必须是 crate 级别的。 
一般来讲，可能的话最好还是尽量让宏展开递归次数保持在默认值以下，因为会影响编译时间。


[recursion_limit]: https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute
